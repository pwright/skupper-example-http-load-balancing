title: Skupper HTTP load balancing
subtitle: Deploying multiple http services for anycast access across cluster
github_actions_url: https://github.com/skupperproject/skupper-example-hello-world/actions/workflows/main.yaml
overview: |
  This tutorial demonstrates how to deploy a set of http servers across multiple clusters and observe anycast application routing over a Virtual Application Network.

  In this tutorial, you will deploy http servers to both a public and a private cluster. You will also create http clients that will access the http servers via the same address. You will observe how the VAN supports anycast application addressing by balancing client requests across the https servers on both the public and private cluster.
sites:
  public1:
    kubeconfig: ~/.kube/config-public1
    namespace: public1
  public2:
    kubeconfig: ~/.kube/config-public2
    namespace: public2
  private1:
    kubeconfig: ~/.kube/config-private1
    namespace: private1
  private2:
    kubeconfig: ~/.kube/config-private2
    namespace: private2
steps:
  - standard: install_the_skupper_command_line_tool
  - standard: configure_separate_console_sessions
  - standard: access_your_clusters
  - standard: set_up_your_namespaces
  - standard: install_skupper_in_your_namespaces
  - standard: check_the_status_of_your_namespaces
  - standard: link_your_namespaces
  - title: Link the private clusters
    preamble: |
      Use `skupper token create` 
      and create links
    commands:
      public1:
        - run: skupper token create /tmp/public1.yaml --uses 2
          output: token created
      private1:
        - run: skupper link create /tmp/public1.yaml
          output: link created
      private2:
        - run: skupper link create /tmp/public1.yaml
          output: link created
  - title: Deploy the HTTP service
    preamble: |
      After creating the application router network, deploy the HTTP services. The **private1** and **public1** clusters will be used to deploy the HTTP servers and the **public2** and **private2** clusters will be used to enable client http communications to the servers.
    commands:
      public1:
        - run: kubectl apply -f ./server.yaml
          output: created
      private1:
        - run: kubectl apply -f ./server.yaml
          output: created
  - title: Expose the HTTP service
    preamble: |
      Use `skupper create` to create a service.
    commands:
      public1:
        - run: skupper service create httpsvc 8080 --protocol tcp
          output: service created
  - title: Bind the service to the deployment
    preamble: |
      Bind services to deployments
    commands:
      public1:
        - await: deployment/http-server
        - run: skupper service bind httpsvc deployment http-server
          output: bind
      private1:
        - await: deployment/http-server
        - run: skupper service bind httpsvc deployment http-server
          output: bind
  - title: Deploy the HTTP clients
    preamble: |
      Deploy clients
    commands:
      public2:
        - run: kubectl apply -f ./client.yaml
          output: bind
      private2:
        - run: kubectl apply -f ./client.yaml
          output: bind
  - title: Review client logs
    preamble: |
      Write client logs to /tmp
    commands:
      public2:
        - await: deployment/http-client
        - run: kubectl logs $(kubectl get pod -l application=http-client -o=jsonpath='{.items[0].metadata.name}')
          output: |
            Service Name: HTTPSVC
            Service Host: 10.105.108.176
            Service Port: 8080
            Configured concurrency: 50
            Query URL: http://10.105.108.176:8080/request

            ======== Rates per server-pod ========
            http-server-774567c64f-n2qt9: 75.5
            http-server-774567c64f-qw9kw: 84.5
            http-server-774567c64f-2mm88: 87
            http-server-774567c64f-mxfhx: 73
      private2:
        - await: deployment/http-client
        - run: kubectl logs $(kubectl get pod -l application=http-client -o=jsonpath='{.items[0].metadata.name}')
          output: |
            Service Name: HTTPSVC
            Service Host: 10.105.108.176
            Service Port: 8080
            Configured concurrency: 50
            Query URL: http://10.105.108.176:8080/request

            ======== Rates per server-pod ========
            http-server-774567c64f-n2qt9: 75.5
            http-server-774567c64f-qw9kw: 84.5
            http-server-774567c64f-2mm88: 87
            http-server-774567c64f-mxfhx: 73

  - standard: accessing_the_web_console
  - standard: cleaning_up
    commands:
      public1:
        - run: skupper delete
        - run: kubectl delete service/frontend
        - run: kubectl delete deployment/frontend
      private1:
        - run: skupper delete
        - run: kubectl delete deployment/backend

summary: |
  This example locates the frontend and backend services in different
  namespaces, on different clusters.  Ordinarily, this means that they
  have no way to communicate unless they are exposed to the public
  internet.

  Introducing Skupper into each namespace allows us to create a virtual
  application network that can connect services in different clusters.
  Any service exposed on the application network is represented as a
  local service in all of the linked namespaces.

  The backend service is located in `east`, but the frontend service
  in `west` can "see" it as if it were local.  When the frontend
  sends a request to the backend, Skupper forwards the request to the
  namespace where the backend is running and routes the response back to
  the frontend.

  <img src="images/sequence.svg" width="640"/>
